Per contenere i dati degli eventi è stata usata base di dati sqlite per la sua facilità di utilizzo e di integrazione.

Note sui tipi di dati scelti:

Per i CAP è stato utilizzato INTEGER invece di TEXT perchè sappiamo la natura dei nostri dati. TEXT coinvolgerebbe un utilizzo di espressioni regolari complicati (es. /[0-9]{5}/) per garantire l'integrità della base di dati, i quali non sono sopportati neanche sopportanti di predefinito da SQLite. Siccome i CAP Italiani sono tutti numerici è molto più facile verificare che i numeri si trovano nel range [0, 99999] con un semplice "CHECK(`cap` BETWEEN 0 AND 99999)" e aggiungere gli zeri d'avanti prima della selezione dei dati. Inoltre, questo approccio utilizza meno memoria (il che non fa parte delle nostre priorità comunque).

Per il tempo è stato utilizzato INTEGER che rappresenta Unix Epoch. Questa scelta permette di semplificare la validazione dei dati.

Per lo stato dell'evento è stato utilizzato un TEXT. È stato scelto TEXT perchè SQLite non sopporta gli ENUM. È possibile utilizzare gli INTEGER per gli stati avendo una conversione complicata fatta tramite un CASE statement. Oppure, si potrebbe usare una tabella a parte che contiene tutti i possibili valori dello stato. Il che comporterebbe l'utilizzo degli ASSERT e degli TRIGGER. Considerando tutti i compromessi, tipo TEXT richiede molte meno risorse per l'implementazione e mantenimento (ciò fa parte delle nostre priorità).

Per il tipo di evento è stato usato un semplice TEXT NOT NULL perchè non conosciamo i possibili valori in anticipo.
